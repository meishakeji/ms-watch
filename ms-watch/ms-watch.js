(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["meisha_watch"] = factory();
	else
		root["meisha_watch"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/js-base64/base64.js":
/*!******************************************!*\
  !*** ./node_modules/js-base64/base64.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
;
(function (global, factory) {
     true
        ? module.exports = factory()
        : 0;
}((typeof self !== 'undefined' ? self
    : typeof window !== 'undefined' ? window
        : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g
            : this), function () {
    'use strict';
    /**
     *  base64.ts
     *
     *  Licensed under the BSD 3-Clause License.
     *    http://opensource.org/licenses/BSD-3-Clause
     *
     *  References:
     *    http://en.wikipedia.org/wiki/Base64
     *
     * @author Dan Kogai (https://github.com/dankogai)
     */
    var version = '3.7.2';
    /**
     * @deprecated use lowercase `version`.
     */
    var VERSION = version;
    var _hasatob = typeof atob === 'function';
    var _hasbtoa = typeof btoa === 'function';
    var _hasBuffer = typeof Buffer === 'function';
    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = (function (a) {
        var tab = {};
        a.forEach(function (c, i) { return tab[c] = i; });
        return tab;
    })(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === 'function'
        ? Uint8Array.from.bind(Uint8Array)
        : function (it, fn) {
            if (fn === void 0) { fn = function (x) { return x; }; }
            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
        };
    var _mkUriSafe = function (src) { return src
        .replace(/=/g, '').replace(/[+\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };
    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\+\/]/g, ''); };
    /**
     * polyfill version of `btoa`
     */
    var btoaPolyfill = function (bin) {
        // console.log('polyfilled');
        var u32, c0, c1, c2, asc = '';
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length;) {
            if ((c0 = bin.charCodeAt(i++)) > 255 ||
                (c1 = bin.charCodeAt(i++)) > 255 ||
                (c2 = bin.charCodeAt(i++)) > 255)
                throw new TypeError('invalid character found');
            u32 = (c0 << 16) | (c1 << 8) | c2;
            asc += b64chs[u32 >> 18 & 63]
                + b64chs[u32 >> 12 & 63]
                + b64chs[u32 >> 6 & 63]
                + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    /**
     * does what `window.btoa` of web browsers do.
     * @param {String} bin binary string
     * @returns {string} Base64-encoded string
     */
    var _btoa = _hasbtoa ? function (bin) { return btoa(bin); }
        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }
            : btoaPolyfill;
    var _fromUint8Array = _hasBuffer
        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }
        : function (u8a) {
            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
            var maxargs = 0x1000;
            var strs = [];
            for (var i = 0, l = u8a.length; i < l; i += maxargs) {
                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
            }
            return _btoa(strs.join(''));
        };
    /**
     * converts a Uint8Array to a Base64 string.
     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
     * @returns {string} Base64 string
     */
    var fromUint8Array = function (u8a, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const utob = (src: string) => unescape(encodeURIComponent(src));
    // reverting good old fationed regexp
    var cb_utob = function (c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                    + _fromCC(0x80 | (cc & 0x3f)))
                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                        + _fromCC(0x80 | (cc & 0x3f)));
        }
        else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                + _fromCC(0x80 | (cc & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-8 string
     * @returns {string} UTF-16 string
     */
    var utob = function (u) { return u.replace(re_utob, cb_utob); };
    //
    var _encode = _hasBuffer
        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }
        : _TE
            ? function (s) { return _fromUint8Array(_TE.encode(s)); }
            : function (s) { return _btoa(utob(s)); };
    /**
     * converts a UTF-8-encoded string to a Base64 string.
     * @param {boolean} [urlsafe] if `true` make the result URL-safe
     * @returns {string} Base64 string
     */
    var encode = function (src, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe
            ? _mkUriSafe(_encode(src))
            : _encode(src);
    };
    /**
     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
     * @returns {string} Base64 string
     */
    var encodeURI = function (src) { return encode(src, true); };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const btou = (src: string) => decodeURIComponent(escape(src));
    // reverting good old fationed regexp
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function (cccc) {
        switch (cccc.length) {
            case 4:
                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                    | ((0x3f & cccc.charCodeAt(1)) << 12)
                    | ((0x3f & cccc.charCodeAt(2)) << 6)
                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
                return (_fromCC((offset >>> 10) + 0xD800)
                    + _fromCC((offset & 0x3FF) + 0xDC00));
            case 3:
                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    | (0x3f & cccc.charCodeAt(2)));
            default:
                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                    | (0x3f & cccc.charCodeAt(1)));
        }
    };
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-16 string
     * @returns {string} UTF-8 string
     */
    var btou = function (b) { return b.replace(re_btou, cb_btou); };
    /**
     * polyfill version of `atob`
     */
    var atobPolyfill = function (asc) {
        // console.log('polyfilled');
        asc = asc.replace(/\s+/g, '');
        if (!b64re.test(asc))
            throw new TypeError('malformed base64.');
        asc += '=='.slice(2 - (asc.length & 3));
        var u24, bin = '', r1, r2;
        for (var i = 0; i < asc.length;) {
            u24 = b64tab[asc.charAt(i++)] << 18
                | b64tab[asc.charAt(i++)] << 12
                | (r1 = b64tab[asc.charAt(i++)]) << 6
                | (r2 = b64tab[asc.charAt(i++)]);
            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
    };
    /**
     * does what `window.atob` of web browsers do.
     * @param {String} asc Base64-encoded string
     * @returns {string} binary string
     */
    var _atob = _hasatob ? function (asc) { return atob(_tidyB64(asc)); }
        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }
            : atobPolyfill;
    //
    var _toUint8Array = _hasBuffer
        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }
        : function (a) { return _U8Afrom(_atob(a), function (c) { return c.charCodeAt(0); }); };
    /**
     * converts a Base64 string to a Uint8Array.
     */
    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };
    //
    var _decode = _hasBuffer
        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }
        : _TD
            ? function (a) { return _TD.decode(_toUint8Array(a)); }
            : function (a) { return btou(_atob(a)); };
    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };
    /**
     * converts a Base64 string to a UTF-8 string.
     * @param {String} src Base64 string.  Both normal and URL-safe are supported
     * @returns {string} UTF-8 string
     */
    var decode = function (src) { return _decode(_unURI(src)); };
    /**
     * check if a value is a valid Base64 string
     * @param {String} src a value to check
      */
    var isValid = function (src) {
        if (typeof src !== 'string')
            return false;
        var s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    //
    var _noEnum = function (v) {
        return {
            value: v, enumerable: false, writable: true, configurable: true
        };
    };
    /**
     * extend String.prototype with relevant methods
     */
    var extendString = function () {
        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };
        _add('fromBase64', function () { return decode(this); });
        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
        _add('toBase64URI', function () { return encode(this, true); });
        _add('toBase64URL', function () { return encode(this, true); });
        _add('toUint8Array', function () { return toUint8Array(this); });
    };
    /**
     * extend Uint8Array.prototype with relevant methods
     */
    var extendUint8Array = function () {
        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };
        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
        _add('toBase64URI', function () { return fromUint8Array(this, true); });
        _add('toBase64URL', function () { return fromUint8Array(this, true); });
    };
    /**
     * extend Builtin prototypes with relevant methods
     */
    var extendBuiltins = function () {
        extendString();
        extendUint8Array();
    };
    var gBase64 = {
        version: version,
        VERSION: VERSION,
        atob: _atob,
        atobPolyfill: atobPolyfill,
        btoa: _btoa,
        btoaPolyfill: btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode: encode,
        encodeURI: encodeURI,
        encodeURL: encodeURI,
        utob: utob,
        btou: btou,
        decode: decode,
        isValid: isValid,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array,
        extendString: extendString,
        extendUint8Array: extendUint8Array,
        extendBuiltins: extendBuiltins
    };
    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });
    return gBase64;
}));


/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ ((module) => {


const HOST = "test-monitor.meishakeji.com";

const ENV = {
  LOCAL: /^(127.0.0.1|localhost|192.168)/.test(window.location.host),
  DEV: /^(127.0.0.1|localhost|192.168|nathan-|dev-|hank-|kerry-|39.108.58.1)/.test(
    window.location.host
  ),
  TEST: /^test-/.test(window.location.host),
  PRE: /^pre-/.test(window.location.host),
};

const getBaseUrl = () => {
  let baseUrl = "";

  if (ENV.DEV) {
    baseUrl = `//${DEVELOP_LOCAL_HOST}`;
  } else if (ENV.TEST) {
    baseUrl = `//test-${HOST}`;
  } else if (ENV.PRE) {
    baseUrl = HOST ? `//pre-${HOST}` : "";
  } else {
    baseUrl = `//${HOST}`;
  }
  return baseUrl;
};

const TimeLog = [
  {
    key: "redirectTime",
    value: "重定向耗时",
  },
  {
    key: "dnsTime",
    value: "DNS解析耗时",
  },
  {
    key: "connectTime",
    value: "TCP连接耗时",
  },
  {
    key: "requestTime",
    value: "HTTP请求耗时",
  },
  {
    key: "firstByteTime",
    value: "首字节耗时",
  },
  {
    key: "domReadyTime",
    value: "解析dom树耗时",
  },
  {
    key: "whiteTime",
    value: "白屏时间",
  },
  {
    key: "domLoadTime",
    value: "DOMready时间",
  },
  {
    key: "jsEventTime",
    value: "脚本加载时间",
  },
  {
    key: "fpTime",
    value: "FP首屏时间",
  },
  {
    key: "fcpTime",
    value: "FCP首次绘制时间",
  },
  {
    key: "ttiTime",
    value: "首次可交互时间",
  },
  {
    key: "loadTime",
    value: "页面加载完成的时间",
  },
];

// 上报间隔时间
const reportSplitTime = 1000 * 10;
// 错误超过6条上报
const errorNum = 5;

module.exports = {
  getBaseUrl,
  TimeLog,
  reportSplitTime,
  errorNum,
};

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/***/ ((module) => {


// console error warn 错误警告收集类
// console.log 格式化log
class MSConsole {
  constructor() {
    this.console = window.console;
    this.infoList = [];
    this.infoFns = [];
    this.warnList = [];
    this.warnFns = [];
    this.errorList = [];
    this.errorFns = [];
  }

  log(obj, color1 = "#35495e", color2 = "#41b883") {
    for (let key in obj) {
      console.log(
        `%c ${key} %c ${obj[key]} `,
        `background: ${color1} ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff`,
        `background: ${color2} ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff`
      );
    }
  }

  info(callback) {
    const info = this.console.info;
    if (typeof callback === "function") {
      this.infoFns.push(callback);
    }
    window.console.info = (...arg) => {
      this.infoList.push({
        arg,
        url: encodeURIComponent(window.location.href),
      });
      for (let fn of this.infoFns) {
        fn(...arg);
      }
      info(...arg);
    };
  }

  warn(callback) {
    const warn = this.console.warn;
    if (typeof callback === "function") {
      this.warnFns.push(callback);
    }
    window.console.warn = (...arg) => {
      this.warnList.push({
        arg,
        url: encodeURIComponent(window.location.href),
        createTime: Math.floor(Date.now() / 1000),
      });
      for (let fn of this.warnFns) {
        fn(...arg);
      }
      warn(...arg);
    };
  }

  error(callback) {
    const error = this.console.error;
    if (typeof callback === "function") {
      this.errorFns.push(callback);
    }
    window.console.error = (...arg) => {
      this.errorList.push({
        arg,
        url: encodeURIComponent(window.location.href),
        createTime: Math.floor(Date.now() / 1000),
      });
      for (let fn of this.errorFns) {
        fn(...arg);
      }
      error(...arg);
    };
  }

  getInfo() {
    return {
      warnList: this.warnList,
      errorList: this.errorList,
    };
  }

  clearInfo() {
    this.errorList = [];
    this.warnList = [];
  }
}

module.exports = {
  MSConsole,
};

/***/ }),

/***/ "./src/device.js":
/*!***********************!*\
  !*** ./src/device.js ***!
  \***********************/
/***/ ((module) => {


// 主要用于收集设备信息
class MSDevice {
  constructor(performance) {
    this.width =
      document.documentElement.clientWidth || document.body.clientWidth; //浏览器宽度
    this.height =
      document.documentElement.clientHeight || document.body.clientHeight; //浏览器高度
    this.userAgent =
      ("navigator" in window &&
        "userAgent" in navigator &&
        navigator.userAgent.toLowerCase()) || "";
    const p =
      window.performance || window.msPerformance || window.webkitPerformance;

    this.performance = performance || p;
    this.osVersion = this.getOS();
    this.browserVersion = this.getExplore();
    this.network = this.getNetWork();
    
    this.createTime = Date.now();
    this.memory = this.getMemory();
  }

  getOS() {
    var userAgent = this.userAgent;
    var vendor =
      ("navigator" in window &&
        "vendor" in navigator &&
        navigator.vendor.toLowerCase()) ||
      "";
    var appVersion =
      ("navigator" in window &&
        "appVersion" in navigator &&
        navigator.appVersion.toLowerCase()) ||
      "";

    if (/mac/i.test(appVersion)) {
      return "MacOSX";
    }
    if (/win/i.test(appVersion)) {
      return "windows";
    }
    if (/linux/i.test(appVersion)) {
      return "linux";
    }
    if (/iphone/i.test(userAgent) || /ipod/i.test(userAgent)) {
      return "ios";
    }
    if (/ipad/i.test(userAgent)) {
      return "ipad";
    }
    if (/android/i.test(userAgent)) {
      return "android";
    }
    if (/win/i.test(appVersion) && /phone/i.test(userAgent)) {
      return "windowsPhone";
    }
  }

  getExplore() {
    var sys = {},
      ua = navigator.userAgent.toLowerCase(),
      s;
    (s = ua.match(/rv:([\d.]+)\) like gecko/))
      ? (sys.ie = s[1])
      : (s = ua.match(/msie ([\d\.]+)/))
      ? (sys.ie = s[1])
      : (s = ua.match(/edge\/([\d\.]+)/))
      ? (sys.edge = s[1])
      : (s = ua.match(/firefox\/([\d\.]+)/))
      ? (sys.firefox = s[1])
      : (s = ua.match(/(?:opera|opr).([\d\.]+)/))
      ? (sys.opera = s[1])
      : (s = ua.match(/micromessenger\/([\d\.]+)/i))
      ? (sys.weixin = s[1])
      : (s = ua.match(/chrome\/([\d\.]+)/))
      ? (sys.chrome = s[1])
      : (s = ua.match(/version\/([\d\.]+).*safari/))
      ? (sys.safari = s[1])
      : (s = ua.match(/weibo\/([\d\.]+)/i))
      ? (sys.weibo = s[1])
      : 0;
    // 根据关系进行判断
    if (sys.ie) return "IE: " + sys.ie;
    if (sys.edge) return "EDGE: " + sys.edge;
    if (sys.firefox) return "Firefox: " + sys.firefox;
    if (sys.weixin) return "weixin: " + sys.weixin;
    if (sys.chrome) return "Chrome: " + sys.chrome;
    if (sys.opera) return "Opera: " + sys.opera;
    if (sys.safari) return "Safari: " + sys.safari;
    if (sys.weibo) return "weibo: " + sys.weibo;
    return "Unkonwn";
  }

  getNetWork() {
    var connection = navigator.connection ||
      navigator.mozConnection ||
      navigator.webkitConnection || { tyep: "unknown" };
    const { effectiveType, downlink, rtt } = connection;

    if (typeof downlink == "number") {
      if (downlink >= 10) {
        connection.type = "wifi";
      } else if (downlink > 2) {
        connection.type = "3g";
      } else if (downlink > 0) {
        connection.type = "2g";
      } else if (downlink == 0) {
        connection.type = "none";
      } else {
        connection.type = "unknown";
      }
    }
    return {
      type: effectiveType || connection.type,
      downlink: downlink,
      rtt: rtt,
      isOnline: navigator.onLine,
    };
  }

  computedSize(value) {
    return value / 1024 / 1024;
  }

  getMemory() {
    const { usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit } =
      this.performance.memory;
    
    return {
      usedSize: this.computedSize(usedJSHeapSize).toFixed(2) + ' MB',
      totalSize: this.computedSize(totalJSHeapSize).toFixed(2) + ' MB',
      limitSize: this.computedSize(jsHeapSizeLimit).toFixed(2) + ' MB',
      // usedJSHeapSize,
      // totalJSHeapSize,
      // jsHeapSizeLimit,
    };
  }

  getInfo() {

    return {
      width: this.width,
      height: this.height,
      userAgent: this.userAgent,
      osVersion: this.osVersion,
      browserVersion: this.browserVersion,
      network: this.network,
      // createTime: this.createTime,
      memory: this.memory,
      // url: window.location.href,
    };
  }
}
module.exports = {
  MSDevice,
};

/***/ }),

/***/ "./src/error.js":
/*!**********************!*\
  !*** ./src/error.js ***!
  \**********************/
/***/ ((module) => {


// 主要用来收集错误信息
const ErrorType = {
  SyntaxError: "语法错误",
  TypeError: "类型错误",
  ReferenceError: "声明错误",
  RangeError: "栈溢出错误",
  ResourceError: "资源加载错误",
  HttpError: "http请求错误",
};

// vue错误、react错误需要 throw 错误
// Vue.config.errorHandler = function (err) {
//   setTimeout(() => {
//     throw err
//   })
// }
// 
class MSError {
  constructor() {
    this.errorList = [];
  }
  // type 为 error 捕获语法等js错误
  // type 为 unhandledrejection 捕获 promise 错误
  recordError(callback) {
    this.handleAddListener("error", (e) => {
      this.dealError(e, callback);
    });
    this.handleAddListener("unhandledrejection", (e) => {
      this.dealError(e, callback);
    });
    this.handlerError((message, source, lineno, colno, error) => {
      const e = {
        type: 'runError',
        message,
        source,
        lineno,
        colno,
        ...error
      }
      this.dealError(e, callback);
    });
  }
  findItem(array, { message, errorType, type, outerHTML }) {
    for(let item of array) {
      const bool1 = message && item.message === message && item.errorType === errorType && item.type === type;
      const bool2 = outerHTML && item.outerHTML === outerHTML && item.errorType === errorType && item.type === type;
      if(bool1 || bool2) {
        return true;
      }
    }
    return false;
  }

  // 处理错误
  dealError(e, callback) {
    const result = this.getError(e);
    
    const bool = this.findItem(this.errorList, result);
    if(!bool) {
      this.errorList.push(result);
    }
    if(callback && typeof callback === 'function') {
      callback(e);
    }
  }

  // TypeError: 类型错误
  getSyntaxError(e) {
    const error = e.error;
    const errorType = error.stack.split(":")[0];
    const errorText = ErrorType[errorType];
    let target = "";
    if (e.target === window) {
      target = "window";
    } else if (e.target === document) {
      target = "document";
    } else {
      target = e.target && e.target.nodeName || '';
    }
    let obj = {
      errorText,
      errorType,
      type: e.type,
      message: error.message,
      stack: error.stack,
      nodeName: target,
    };
    if(error.colno) {
      Object.assign(obj, {
        colno: error.colno,
      })
    }
    if(error.lineno) {
      Object.assign(obj, {
        lineno: error.lineno,
      })
    }
    return obj;
  }
  // promise 错误
  getPromiseError(e) {
    const reason = e.reason;
    const errorList = reason.stack && reason.stack.split(":");
    const errorType = errorList && errorList[0];
    const errorText = ErrorType[errorType] || '未定义错误';
    let obj = {
      errorText,
      errorType,
      type: e.type,
      message: reason.message,
      stack: reason.stack,
      nodeName: 'window',
    };
    return obj;
  }
  // ResourceError: 资源加载错误
  getResourceError(e) {
    let obj = {};
    const target = e.target;
    const nodeNames = ["img", "script", "link"];
    const name = target.nodeName.toLocaleLowerCase();
    if (nodeNames.includes(name)) {
      obj = {
        nodeName: target.nodeName,
        errorText: "资源加载错误",
        errorType: "ResourceError",
        src: target.src || target.href,
        className: target.className,
        outerHTML: target.outerHTML,
        type: e.type,
      };
      if(name === 'img') {
        Object.assign(obj, {
          top: target.x,
          left: target.y,
          width: target.width,
          height: target.height,
        })
      }
    }
    return obj;
  }
  // 运行的错误
  getRunError(e) {
    const errorType = e.message && e.message.split(':')[0] && e.message.split(':')[0].split(' ')[1];
    const errorText = ErrorType[errorType];
    return {
      nodeName: 'window',
      errorText,
      errorType,
      type: 'runError',
      message: e.message,
      source: e.source,
      lineno: e.lineno,
      colno: e.colno,
      stack: e.stack,
    }
  }

  getError(e) {
    const error = e.error;
    const reason = e.reason;
    let obj = {};
    if (e.target && e.target.nodeName) {
      obj = this.getResourceError(e);
    } else if (error) {
      obj = this.getSyntaxError(e);
    } else if (reason) {
      obj = this.getPromiseError(e);
    } else if(e.type === 'runError') {
      obj = this.getRunError(e);
    }
    Object.assign(obj, {
      createTime: Math.floor(Date.now() / 1000),
      // id: guid(24),
      url: encodeURIComponent(window.location.href),
    })
    return obj;
  }
  // 图片、script、css加载错误
  handleAddListener(type, fn) {
    if (window.addEventListener) {
      window.addEventListener(type, fn, true);
    } else {
      window.attachEvent("on" + type, fn);
    }
  }
  handlerError(fn) {
    window.onerror = fn;
  }

  clearInfo() {
    this.errorList = [];
  }
}

module.exports = {
  MSError,
};


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 用户信息|内存信息| 导航信息|网络质量|用户操作路径｜javascript 异常信息 ｜ js执行时间 ｜ user-agent｜报文生成时间 

const { MSTiming } = __webpack_require__(/*! ./timing.js */ "./src/timing.js");
const { MSDevice } = __webpack_require__(/*! ./device.js */ "./src/device.js");
const { MSConsole } = __webpack_require__(/*! ./console.js */ "./src/console.js");
const { TimeLog, reportSplitTime, errorNum } = __webpack_require__(/*! ./config.js */ "./src/config.js");
const { MSError } = __webpack_require__(/*! ./error.js */ "./src/error.js");
const { MSUserAction } = __webpack_require__(/*! ./userInfo.js */ "./src/userInfo.js");
const { MSSendData } = __webpack_require__(/*! ./postData.js */ "./src/postData.js");
const { MSStorage } = __webpack_require__(/*! ./storage.js */ "./src/storage.js");  
const { guid } = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
const { encode, decode } = __webpack_require__(/*! js-base64 */ "./node_modules/js-base64/base64.js");


class MSMain {
  constructor(data) {
    const { projectName, url, router } = data || {};
    this.error = new MSError();
    this.listenLoad();
    this.listenUnload();
    this.listenVisible();
    this.timing = null;
    this.device = null;
    this.mconsole = null;
    this.action = null;
    this.storage = null;
    this.useInfo = null;
    this.timeId = guid();
    window.encode = encode;
    window.decode = decode;
    if(!projectName) {
      throw new Error('projectName 不能为空');
    }
    if(!url) {
      throw new Error('URL 不能为空');
    }
    if(!router) {
      throw new Error('请传入router实例')
    }
    this.projectName = projectName;
    this.url = url;
    this.router = router;
    this.firstEnter = true;
    this.lastTime = 0;
    this.requestId = guid(0, 24, false);
  }

  async init() {
    // 初始化
    const performance =
      window.performance || window.msPerformance || window.webkitPerformance;

    this.timing = new MSTiming(performance);
    this.device = new MSDevice();
    this.mconsole = new MSConsole();
    this.action = new MSUserAction(this.router);
    this.userInfo = this.action.userInfo.getUserInfo() || {};

    this.storage = new MSStorage(this.userInfo);
   

    const timing = await this.timing.getTime();
    let obj = {};
    for (let { key, value } of TimeLog) {
      obj[value] = `${timing[key]}ms`;
    }
    this.mconsole.log(obj);
    this.action.listenRouter();
    this.action.listenAction();
    this.mconsole.warn();
    this.mconsole.error();
    this.error.recordError(this.errorReport.bind(this));

    this.msend = new MSSendData({
      url: this.url,
      method: 'post',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
    });
    this.report()
  }

  getData() {
    const timing = this.timing.getTime();
    const device = this.device.getInfo();
    const consoleInfo = this.mconsole.getInfo();
    const action = this.action.getInfo();
    delete action.userInfo;
    const { userId, name, realname, phoneNo } = this.userInfo;
    return {
      project: this.projectName,
      requestId: this.requestId,
      httpHost: window.location.host,
      requestUri: encodeURIComponent(window.location.href),
      user: {
        userId,
        name: name || realname,
        phoneNo,
      },
      timing: this.firstEnter ? timing : null,
      device: this.firstEnter ? device : null,
      logs: [
        {
          "console": consoleInfo,
          "action": action,
          "typeError": this.error.errorList,
        }
      ]
    };
  }

  getLogs() {
    const consoleInfo = this.mconsole.getInfo();
    const action = this.action.getInfo();
    return {
      "console": consoleInfo,
      "action": action,
      "typeError": this.error.errorList,
    };
  }

  clearData() {
    this.mconsole.clearInfo();
    this.action.clearInfo();
    this.firstEnter = false;
  }
  listenLoad() {
    this.error.handleAddListener("load", () => {
      setTimeout(async () => {
        this.init();
      }, 200)
    });
  }
  listenUnload() {
    let that = this;
    this.error.handleAddListener("unload", () => {
      that.saveLog();
    });
  }

  listenVisible() {
    let that = this;
    this.error.handleAddListener("visibilitychange", (e) => {
      const state = document.visibilityState === 'visible';
      if(state) {
        that.saveLog();
      }
    });
  }

  saveLog() {
    const data = this.getData();
    const errList = this.storage && this.storage.get('MsError') || [];
    if(errList.length > 0) {
      data.logs.unshift(...errList);
    }
    this.storage.set('MsError', data.logs);
    return data;
  }

  clearLog() {
    this.storage.set('MsError', []);
  }

  encodeData(value) {
    const result = JSON.stringify(value);
    return encode(result);
  }
  // 上报页面加载时间、设备信息
  async report() {
    const errList = this.saveLog();
    if(this.firstEnter) {
      this.reportData(errList);
    }
  }
  // 上报错误
  errorReport() {
    const errorList = this.error.errorList
    const errList = this.saveLog();
    const bool1 = Date.now() - this.lastTime > reportSplitTime;
    const bool2 = errorList.length >= errorNum;

    if (bool1 && bool2) {
      this.reportData(errList);
    }
  }

  async reportData(errList) {
    try {
      await this.msend.xhrReport(this.encodeData(errList));
      this.clearData();
      this.clearLog();
      this.lastTime = Date.now();
    } catch(err) {
      throw err
    }
  }
}

module.exports = {
  MSMain
};

/***/ }),

/***/ "./src/postData.js":
/*!*************************!*\
  !*** ./src/postData.js ***!
  \*************************/
/***/ ((module) => {


// 上报数据
class MSSendData {
  constructor({ url, headers, method }) {
    this.url = url;
    this.headers = headers;
    this.method = method;
  }

  xhrReport(data) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open(this.method, this.url, false);
      // xhr.withCredentials = true;
      Object.keys(this.headers).forEach((key) => {
        xhr.setRequestHeader(key, this.headers[key]);
      });
      xhr.onreadystatechange = () => {
        if(+xhr.readyState === 4 && +xhr.status === 200) {
          resolve(xhr.responseText)
        }
      }

      xhr.onerror = (err) => {
        reject(err)
      }
      xhr.ontimeout = (err) => {
        reject(err)
      }
      xhr.send(this.transformData(data));
    })
  }

  transformData(data) {
    if (this.headers['Content-Type'] === 'application/x-www-form-urlencoded') {
      const params = new URLSearchParams();
      params.append('data', data);
      return params;
    } else {
      // 其他类型
      return JSON.stringify(data);
    }
  }
  sendBeacon(data) {
    return new Promise((resolve, reject) => {
      try {
        const blob = new Blob([JSON.stringify(data)], { 
          type: 'application/x-www-form-urlencoded; charset=UTF-8'
        });
        navigator.sendBeacon(this.url, blob);
        resolve(this.data);
      } catch (error) {
        reject(error);
      }
    })
  }
}

module.exports = {
  MSSendData,
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/***/ ((module) => {


// 存储类
class MSStorage {
  constructor(userInfo) {
    this.localStorage = window.localStorage;
    this.userId = userInfo.userId;
  }

  get(key) {
    const result = this.localStorage.getItem(key);
    if (result) {
      return JSON.parse(result);
    }
    return false;
  }

  set(key, value) {
    this.localStorage.setItem(`${key}-${this.userId}`, JSON.stringify(value));
  }

  remove(key) {
    this.localStorage.removeItem(key);
  }

}

module.exports = {
  MSStorage,
};

/***/ }),

/***/ "./src/timing.js":
/*!***********************!*\
  !*** ./src/timing.js ***!
  \***********************/
/***/ ((module) => {


// const ttiPolyfill = require('tti-polyfill');
// 获取页面加载时间
class MSTiming {
  constructor(performance) {
    const p =
      window.performance ||
      window.msPerformance ||
      window.webkitPerformance;

    this.performance = performance || p;
    this.timing = performance.timing
  }

  getTime() {
    var t = this.timing;
    var obj = {
      // timing: this.timing
    };
    // 重定向次数
    obj.redirectCount = this.performance.navigation.redirectCount;
    // 重定向耗时
    obj.redirectTime = t.redirectEnd - t.redirectStart
    // DNS解析，DNS查询耗时
    obj.dnsTime = t.domainLookupEnd - t.domainLookupStart;
    // TCP链接耗时
    obj.connectTime = t.connectEnd - t.connectStart;
    // HTTP请求耗时
    obj.requestTime = t.responseEnd - t.requestStart;
    // 获得首字节耗费时间，也叫TTFB
    obj.firstByteTime = t.responseStart - t.navigationStart;
    // 解析dom树耗时
    obj.domReadyTime = t.domComplete - t.responseEnd;
    // 白屏时间耗时
    obj.whiteTime = t.responseStart - t.navigationStart;
    // DOMready时间
    obj.domLoadTime = t.domContentLoadedEventEnd - t.navigationStart;
    // 脚本加载时间
    obj.jsEventTime = t.domContentLoadedEventEnd - t.domContentLoadedEventStart
    // 页面加载完成的时间 即：onload时间
    obj.loadTime = t.loadEventEnd - t.navigationStart;
    // 首屏时间
    obj.paintTime = t.domComplete - t.navigationStart;
    // 首次可交互时间
    obj.ttiTime = t.domInteractive - t.navigationStart;
    // FP首屏时间   FCP首次绘制时间  首次可交互时间  用户首次交互时间  
    const res = this.getFPTime();
    // const res = await this.getFirstPaintTime()
    // obj.userKeyTime = {
    //   fmpTime: obj.paintTime,
    //   ...res,
    // }
    const result = {
      ...obj,
      ...res,
      // url: window.location.href,
    };
    for(let key in result) {
      result[key] = Math.floor(result[key])
    } 
    return result;
  }

  getFPTime() {
    const performance = this.performance;
    let obj = {
      fpTime: -1,
      fcpTime: -1,
    };
    if (typeof performance.getEntriesByType === 'function') {
      const fpList = this.performance.getEntriesByName('first-paint');
      const fcpList = this.performance.getEntriesByName('first-contentful-paint');
      let fp = fpList && fpList[0] && fpList[0].startTime
      let fcp = fcpList && fpList[0] && fcpList[0].startTime
      obj = {
        fpTime: fp,
        fcpTime: fcp,
      }
    }
    return obj;
  }

  async getFirstPaintTime() {
    const performance = this.performance
    let obj = {}
    try {
      if (typeof performance.getEntriesByType === 'function') {
        const fpList = this.performance.getEntriesByName('first-paint');
        const fcpList = this.performance.getEntriesByName('first-contentful-paint');
        let fp = fpList && fpList[0] && fpList[0].duration
        let fcp = fcpList && fcpList[0] && fcpList[0].duration
        obj = {
          fpTime: fp,
          fcpTime: fcp,
        }
      } else {
        let fp = -1
        if (chrome && chrome.loadTimes) {
          let loadTimes = window.chrome.loadTimes();
          let { firstPaintTime, startLoadTime } = loadTimes;
          fp = (firstPaintTime - startLoadTime) * 1000;
        } else if (performance.timing && typeof performance.timing.msFirstPaint === 'number') {
          let {msFirstPaint, navigationStart} = performance.timing;
          fp = msFirstPaint - navigationStart;
        }
        obj = {
          fpTime: fp,
          fcpTime: -1,
        }
      }
      const tti = await ttiPolyfill.getFirstConsistentlyInteractive()
      obj['tti'] = tti
      return obj
    } catch (error) {
      console.warn(error)
      return obj
    }
  }
}

module.exports = {
  MSTiming,
};

/***/ }),

/***/ "./src/userInfo.js":
/*!*************************!*\
  !*** ./src/userInfo.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


const { MSStorage } = __webpack_require__(/*! ./storage.js */ "./src/storage.js");
const { guid } = __webpack_require__(/*! ./utils.js */ "./src/utils.js");

// 获取用户信息
// 各系统用户信息需要存储在localStorage中的 userInfo 字段
class MSUserInfo {
  constructor() {
    const userInfo = localStorage.getItem('userInfo');
    if(userInfo) {
      this.userInfo = JSON.parse(userInfo);
    } else {
      this.userInfo = {};
    }
    this.userId = this.userInfo && this.userInfo.userId;
  }
  getUserInfo() {
    return this.userInfo || {};
  }

}

// 记录采集用户信息操作
class MSUserAction {
  constructor(router) {
    if(!router) {
      throw new Error('请传入router实例')
    }
    this.userInfo = new MSUserInfo();
    this.router = router;
    this.routeList = [];
    this.clickList = [];
    this.content = '';
  }
  // 监听路由， 需要传入 router 实例
  // TODO 待优化，可以解藕 
  // 利用 window.onhashchange和 window.onpopstate获取路由跳转信息
  listenRouter(callback) {
    this.router.beforeEach && this.router.beforeEach((to, from, next) => {
      const obj = {
        to: {
          fullPath: to.fullPath,
          name: to.name,
          params: to.params,
          path: to.path,
          query: to.query
        },
        from: {
          fullPath: from.fullPath,
          name: from.name,
          params: from.params,
          path: from.path,
          query: from.query
        },
        createTime: Math.floor(Date.now() / 1000),
      };
      this.routeList.push(obj);
      if(callback && typeof callback === 'function') {
        callback(to, from);
      }
      next();
    });
  }

  listenAction() {
    this.listenClick();
  }

  handleAddListener(type, fn) {
    if (window.addEventListener) {
      window.addEventListener(type, fn, true);
    } else {
      window.attachEvent("on" + type, fn);
    }
  }
  // 获取 className ID
  getClassName(target) {
    let ids = target.id;
    let className = target.className;
    while(target && !target.id && !target.className) {
      ids += ` ${target.id}`;
      className += ` ${target.className}`;
      target = target.parentElement;
    }

    return `id选择器:${ids} class选择器:${className}`;
  }

  findItem(array, { left, top, url }) {
    for(let item of array) {
      const bool1 = Math.abs(item.left - left) < 6;
      const bool2 = Math.abs(item.top - top) < 6;
      if(bool1 && bool2) {
        return true;
      }
    }
    return false;
  }
  // 监听点击事件，获取点击位置，点击元素信息
  listenClick() {
    this.handleAddListener('click', (e) => {
      const target = e.target;
      const innerText = target.innerText;
      const className = this.getClassName(target);
      const obj = {
        innerText,
        className,
        left: e.clientX || e.x || e.offsetX || e.pageX,
        top: e.clientY || e.y || e.offsetY || e.pageY,
        createTime: Math.floor(Date.now() / 1000),
        url: encodeURIComponent(window.location.href),
      };

      if(!this.findItem(this.clickList, obj)) {
        this.clickList.push(obj);
      }
    })
  }

  getInfo() {
    return {
      userInfo: this.userInfo.userInfo,
      clickList: this.clickList,
      routeList: this.routeList,
    }
  }

  clearInfo() {
    this.clickList = [];
    this.routeList = [];
  }
}


module.exports = {
  MSUserAction,
  MSUserInfo,
};

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((module) => {



const guid = (start, end, isSlice = true) => {
  const result = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
  return isSlice ? result.slice(start, end) : result;
}

const tryError = (callback) => {
  if(callback && typeof callback === 'function') {
    try {
      callback();
    } catch (err) {
      console.error(err);
    }
  }
}


window.log = console.log.bind(console);

module.exports = {
  guid,
  tryError,
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=ms-watch.js.map